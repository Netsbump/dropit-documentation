---
title: Couches de pr√©sentations
description: Architectures web et mobile
---

## Introduction

Apr√®s avoir d√©taill√© l'[acc√®s aux donn√©es](/conception/acces-donnees), cette section s'int√©resse √† l'impl√©mentation concr√®te des couches de pr√©sentation web et mobile qui constituent les points d'entr√©e des utilisateurs vers l'application. L'[architecture logicielle](/conception/architecture) a pr√©sent√© la vision d'ensemble ; nous explorons ici comment ces choix se traduisent en composants React et patterns d'impl√©mentation, en r√©utilisant les [packages partag√©s du monorepo](/conception/architecture#packages-partag√©s-du-monorepo) (`@dropit/schemas`, `@dropit/contract`, `@dropit/i18n`) pour garantir la coh√©rence des r√®gles m√©tier entre plateformes.

## Architecture Web App

### Organisation modulaire

L'architecture frontend adopte une organisation par features inspir√©e du Domain-Driven Design, structurant le code selon le vocabulaire m√©tier ("athletes", "exercises", "workout", "planning") plut√¥t que par pr√©occupations techniques. Cette approche √©tablit un langage commun avec les utilisateurs et facilite le d√©veloppement parall√®le.

```markdown
apps/web/src/
‚îú‚îÄ‚îÄ features/              # Modules m√©tier isol√©s
‚îÇ   ‚îú‚îÄ‚îÄ athletes/          # Gestion des athl√®tes
‚îÇ   ‚îú‚îÄ‚îÄ exercises/         # Catalogue d'exercices  
‚îÇ   ‚îú‚îÄ‚îÄ workout/           # Cr√©ation et √©dition programmes
‚îÇ   ‚îú‚îÄ‚îÄ planning/          # Interface calendaire
‚îÇ   ‚îî‚îÄ‚îÄ complex/           # Gestion des complexes
‚îú‚îÄ‚îÄ shared/                # Composants et logique partag√©s
‚îÇ   ‚îú‚îÄ‚îÄ components/ui/     # Design system Shadcn/ui
‚îÇ   ‚îú‚îÄ‚îÄ hooks/             # Hooks React r√©utilisables
‚îÇ   ‚îî‚îÄ‚îÄ utils/             # Utilitaires communs
‚îî‚îÄ‚îÄ routes/                # Structure de routage Tanstack Router
```

Chaque feature encapsule sa logique m√©tier sp√©cifique et ses r√®gles de validation propres, respectant le principe de responsabilit√© unique. Cette isolation permet d'appliquer des r√®gles business diff√©renci√©es (donn√©es personnelles pour `athletes/`, r√®gles biom√©caniques pour `exercises/`) sans cr√©er de couplage entre modules.

### Gestion des formulaires avec React Hook Form

Pour la gestion des formulaires dans DropIt, j'avais besoin d'impl√©menter efficacement des fonctionnalit√©s comme la validation en temps r√©el, la gestion des erreurs, et la soumission asynchrone sans r√©inventer ces m√©canismes from scratch. React Hook Form me fournit ces fonctionnalit√©s cl√©s en main : gestion automatique des √©tats de formulaire, validation int√©gr√©e, et optimisation des performances via des champs non contr√¥l√©s.

Cette approche me permet de me concentrer sur la logique m√©tier sp√©cifique √† l'halt√©rophilie plut√¥t que sur l'impl√©mentation des m√©canismes de base des formulaires.

> **Exemples d'impl√©mentation** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/) 

### Int√©gration de la validation Zod partag√©e

L'un des aspects les plus enrichissants de cette impl√©mentation a √©t√© l'int√©gration des sch√©mas Zod d√©finis dans le package partag√© [`@dropit/schemas`](/conception/architecture#dropit-schemas--validation-centralis√©e-avec-zod), √©galement utilis√©s c√¥t√© API dans la [couche d'acc√®s aux donn√©es](/conception/acces-donnees). Cette approche r√©sout une probl√©matique r√©currente : maintenir la coh√©rence des r√®gles de validation entre le frontend et le backend.

Cette d√©finition commune me permet d'exploiter les m√™mes sch√©mas pour deux usages compl√©mentaires : validation des donn√©es re√ßues par l'API c√¥t√© serveur, et validation des formulaires c√¥t√© client avant envoi. Cette r√©utilisation garantit une parfaite synchronisation des r√®gles de validation sur l'ensemble de l'application.

L'avantage le plus significatif r√©side dans l'√©limination des divergences de validation. Avec cette approche centralis√©e, je garantis qu'un exercice respectant les contraintes c√¥t√© client sera n√©cessairement accept√© par l'API, r√©duisant drastiquement les erreurs d'int√©gration.

> **Exemples d'int√©gration Zod** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/)

### Strat√©gie de synchronisation des donn√©es avec Tanstack Query

Dans le contexte de DropIt, la question de la gestion d'√©tat s'est pos√©e rapidement : comment synchroniser efficacement les donn√©es entre les diff√©rents √©crans de l'application ? Un coach qui cr√©e un exercice dans le catalogue doit le voir appara√Ætre imm√©diatement dans l'interface de cr√©ation de programme, sans rechargement manuel.

J'ai choisi Tanstack Query qui traite directement les requ√™tes HTTP comme source de v√©rit√© plut√¥t que de dupliquer les donn√©es serveur dans un store client. Cette approche correspond mieux √† la r√©alit√© d'une application moderne o√π la majorit√© de l'√©tat provient effectivement du backend.

L'invalidation automatique du cache constitue un m√©canisme particuli√®rement √©l√©gant : lorsqu'un coach cr√©e un nouvel exercice, Tanstack Query invalide automatiquement toutes les requ√™tes li√©es aux exercices, garantissant leur rechargement transparent lors du prochain acc√®s. Cette synchronisation √©limine les incoh√©rences que j'avais pu observer dans des projets ant√©rieurs.

Tanstack Query encapsule toute la logique complexe de gestion d'√©tat dans ses hooks `useQuery` et `useMutation`, me permettant de me concentrer sur la logique m√©tier plut√¥t que sur la plomberie de la synchronisation des donn√©es.

> **Exemples d'impl√©mentation Tanstack Query** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/)

### Routage typ√© avec Tanstack Router

Dans le contexte d'une Single Page Application (SPA) comme DropIt, la gestion du routage devient cruciale pour offrir une exp√©rience utilisateur fluide. Les coachs naviguent fr√©quemment entre la cr√©ation de programmes, la gestion des athl√®tes et la planification des s√©ances, n√©cessitant des transitions rapides sans interruption de leur workflow.

J'ai choisi d'explorer Tanstack Router plut√¥t que React Router principalement dans une d√©marche d'apprentissage d'une alternative moderne au routage classique. L'approche file-based routing o√π chaque route correspond √† un fichier m'a sembl√© plus intuitive que la configuration centralis√©e de React Router, facilitant l'organisation et la maintenance du code.

Cette structure hi√©rarchique refl√®te l'organisation logique de l'application et facilite la gestion des layouts imbriqu√©s. Le pr√©fixe `__home` indique les routes prot√©g√©es par authentification, simplifiant la logique de protection des pages.

> **Configuration et exemples de routage** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/)

### Flux de donn√©es

Pour mettre en perspectives tous ces √©lements voici un exemple de flux de donn√©es dans le client web:

```mermaid
sequenceDiagram
    participant Coach as üë® Coach (Utilisateur)
    participant Router as üåê Tanstack Router
    participant Page as üìÑ WorkoutCreatePage
    participant Form as üìù React Hook Form
    participant Validation as ‚úÖ Zod Schema
    participant Query as üîÑ Tanstack Query
    
    Coach->>Router: Navigation vers /workouts/create
    Router->>Page: Rendu du composant
    
    Coach->>Form: Saisie donn√©es programme
    Form->>Validation: Validation temps r√©el
    Validation-->>Form: Erreurs ou succ√®s
    Form-->>Page: Mise √† jour √©tat formulaire
    
    Coach->>Form: Soumission formulaire
    Form->>Validation: Validation finale
    Validation-->>Form: Donn√©es valid√©es
    Form->>Query: useMutation('createWorkout')
    Query-->>Page: √âtat de soumission
    Page-->>Coach: Feedback utilisateur
    
    Query-->>Router: Redirection apr√®s succ√®s
```

L'application suit un flux de donn√©es unidirectionnel o√π Tanstack Query centralise la gestion de l'√©tat serveur, tandis que React se charge de l'√©tat local des composants. Cette s√©paration facilite la maintenance et le d√©bogage et me permet d'isoler les probl√®mes selon leur nature.

La structure respecte une s√©paration entre les diff√©rentes couches : pr√©sentation avec les composants UI, logique m√©tier encapsul√©e dans des hooks personnalis√©s, et communication g√©r√©e par les clients API. Cette organisation facilite non seulement les tests unitaires en isolant chaque responsabilit√©, mais aussi l'√©volution future du code en permettant de modifier une couche sans impacter les autres. Pour optimiser les performances de rendu, j'ai pr√©vu d'impl√©menter une pagination progressive pour les longues listes d'athl√®tes et la technique de lazy loading pour les d√©tails de programmes, √©vitant ainsi de charger l'int√©gralit√© des donn√©es au premier acc√®s.

### Gestion des dates avec date-fns

Dans DropIt, la manipulation des dates intervient fr√©quemment : planification des s√©ances, formatage des dates d'entra√Ænement, calculs de p√©riodes. J'avais besoin d'une solution fiable pour √©viter les pi√®ges classiques de manipulation des objets Date JavaScript natifs.

J'ai choisi date-fns pour son approche fonctionnelle avec des fonctions pures qui ne mutent pas les dates originales. Cette immutabilit√© √©vite les modifications involontaires que j'avais d√©j√† rencontr√©es dans des projets pr√©c√©dents. Sa modularit√© me permet √©galement d'importer uniquement les fonctions n√©cessaires, optimisant la taille du bundle final.

Cette approche garantit une gestion coh√©rente des dates √† travers l'application, √©vitant les incoh√©rences de formatage qui pourraient nuire √† l'exp√©rience utilisateur.

> **Exemples d'utilisation date-fns** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/)

### Drag-and-drop pour la composition

Pour la r√©organisation des exercices dans un programme, j'avais besoin d'une interface permettant de modifier facilement l'ordre des √©l√©ments. L'approche par champs num√©riques aurait fonctionn√©, mais j'ai pr√©f√©r√© une interaction plus directe. J'ai donc choisi d'utiliser la biblioth√®que dnd-kit qui me fournit tous les hooks et utilitaires n√©cessaires pour impl√©menter le drag-and-drop : gestion des √©v√©nements, animations fluides, et support de l'accessibilit√©. Cette solution m'√©vite de r√©inventer la logique complexe de d√©tection des zones de drop.

L'impl√©mentation repose sur le hook `useSortable` qui me donne tous les √©l√©ments n√©cessaires : les `attributes` et `listeners` pour capturer les interactions, la r√©f√©rence `setNodeRef` pour attacher le comportement au DOM, et les propri√©t√©s `transform` et `transition` pour g√©rer les animations. Le composant affiche l'exercice avec ses param√®tres (s√©ries, r√©p√©titions, poids) tout en restant compl√®tement d√©pla√ßable gr√¢ce √† la logique encapsul√©e par dnd-kit.

> **Exemples d'impl√©mentation drag-and-drop** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/)

### Internationalisation c√¥t√© client

Au-del√† de la perspective multilingue, l'impl√©mentation d'un syst√®me d'internationalisation r√©pond √† deux besoins pratiques : externaliser tous les textes dans des fichiers d√©di√©s plut√¥t que dispers√©s dans le code, et mutualiser certains messages (notamment les erreurs) entre l'application web et mobile.

J'ai donc int√©gr√© react-i18next c√¥t√© client en r√©utilisant le package [`@dropit/i18n`](/conception/architecture#dropit-i18n--internationalisation-partag√©e) d√©crit dans l'architecture globale. Cette approche centralis√©e facilite la maintenance des textes et √©vite la duplication de messages entre les plateformes.

Les fichiers de traduction sont organis√©s par domaines m√©tier, permettant une maintenance cibl√©e et une √©volution future facilit√©e.

> **Configuration i18next et exemples** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/)

### TailwindCSS

TailwindCSS adopte une approche CSS atomique avec des classes utilitaires correspondant directement aux propri√©t√©s CSS, permettant de composer les interfaces directement dans le JSX. Cette m√©thodologie √©limine la navigation constante entre fichiers CSS et composants, optimisant le d√©veloppement des formulaires et interfaces de planning.

L'int√©gration avec Vite utilise le compilateur JIT (Just-In-Time) qui g√©n√®re uniquement les styles correspondant aux classes effectivement utilis√©es, optimisant drastiquement la taille du bundle final. Le syst√®me de purge automatique √©limine les classes non utilis√©es, r√©sultant en un fichier CSS de quelques kilooctets.

L'approche responsive mobile-first utilise les pr√©fixes `sm:`, `md:`, `lg:` pour adapter les interfaces aux diff√©rentes tailles d'√©cran sans media queries manuelles.

> **Configuration Tailwind et exemples** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/)

### Shadcn/ui

Shadcn/ui s'appuie sur Radix UI pour impl√©menter nativement les recommandations WCAG 2.1 et respecter les crit√®res RGAA (R√©f√©rentiel G√©n√©ral d'Am√©lioration de l'Accessibilit√©). Cette conformit√© garantit l'utilisabilit√© par tous les athl√®tes, y compris ceux en situation de handicap.

L'impl√©mentation respecte les crit√®res RGAA essentiels : structure s√©mantique avec r√¥les ARIA appropri√©s, gestion du focus pour la navigation clavier, contrastes conformes (ratio 4.5:1 minimum), et messages d'erreur associ√©s via `aria-describedby`. L'attribut `role="alert"` assure l'annonce imm√©diate des erreurs par les lecteurs d'√©cran.

L'approche "copy-paste" offre un contr√¥le total sur l'adaptation aux sp√©cificit√©s m√©tier tout en conservant les garanties d'accessibilit√© de Radix UI. Les composants √©tant con√ßus pour √™tre tree-shakeable, Vite peut √©liminer automatiquement les composants non utilis√©s du bundle final, r√©duisant la taille du JavaScript t√©l√©charg√© et r√©pondant aux enjeux de durabilit√© num√©rique.

> **Exemples d'impl√©mentation Shadcn/ui** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/)

### Syst√®me d'ic√¥nes avec Lucide React

Lucide React, fork am√©lior√© de Feather Icons, propose un style unifi√© avec des traits fins et des proportions harmonieuses qui s'int√®grent parfaitement avec l'esth√©tique moderne de Tailwind. Cette coh√©rence visuelle facilite la reconnaissance et l'apprentissage de l'interface dans le contexte m√©tier de DropIt.

L'impl√©mentation technique pr√©sente des avantages significatifs en termes de performance : contrairement aux font-icons qui imposent le t√©l√©chargement complet de la police, Lucide permet un tree-shaking granulaire o√π seules les ic√¥nes import√©es sont incluses dans le bundle final gr√¢ce √† Vite. Cette approche r√©duit la taille du JavaScript t√©l√©charg√©, aspect crucial pour l'√©coconception. Les ic√¥nes √©tant des composants SVG React natifs, elles b√©n√©ficient du rendu optimis√© de React et peuvent √™tre styl√©es dynamiquement.

L'int√©gration respecte scrupuleusement les recommandations d'accessibilit√©, chaque ic√¥ne √©tant impl√©ment√©e avec les attributs ARIA appropri√©s selon son contexte d'usage.

> **Exemples d'impl√©mentation Lucide React** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/)

### Optimisations du build avec Vite

Vite, bundler moderne rempla√ßant Webpack, automatise les optimisations essentielles sans configuration complexe. Il applique trois optimisations cruciales : le code splitting qui g√©n√®re automatiquement des chunks s√©par√©s pour chaque route Tanstack Router, permettant aux utilisateurs de t√©l√©charger uniquement le JavaScript n√©cessaire √† la page consult√©e ; le tree shaking qui √©limine automatiquement le code non utilis√© (composants Shadcn/ui non utilis√©s, fonctions d'internationalisation des langues non activ√©es) ; et la compression des assets qui minifie le CSS et JavaScript tout en optimisant les images, am√©liorant les performances particuli√®rement critiques pour l'usage mobile en salle de sport.

> **Configuration Vite et optimisations** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/)

## Architecture Mobile App

### Structure du projet mobile

```markdown
apps/mobile/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/          # Composants React Native
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AuthProvider.tsx # Gestion authentification globale
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginScreen.tsx  # √âcran de connexion
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DashboardScreen.tsx # Interface principale athl√®te
‚îÇ   ‚îî‚îÄ‚îÄ lib/                 # Configuration et clients
‚îÇ       ‚îú‚îÄ‚îÄ auth-client.ts   # Client Better Auth pour mobile
‚îÇ       ‚îî‚îÄ‚îÄ api.ts          # Client HTTP configur√©
‚îú‚îÄ‚îÄ assets/                  # Images et ressources natives
‚îÇ   ‚îú‚îÄ‚îÄ icon.png            # Ic√¥ne application
‚îÇ   ‚îú‚îÄ‚îÄ splash-icon.png     # √âcran de d√©marrage
‚îÇ   ‚îî‚îÄ‚îÄ adaptive-icon.png   # Ic√¥ne adaptative Android
‚îú‚îÄ‚îÄ app.json                 # Configuration Expo
‚îî‚îÄ‚îÄ App.tsx                 # Point d'entr√©e de l'application
```

La structure mobile reste volontairement simple avec une s√©paration entre les composants d'interface et la configuration des services externes. Cette simplicit√© architecturale facilite la maintenance et r√©duit la complexit√© cognitive, aspect important dans un contexte d'apprentissage du d√©veloppement mobile.

Les assets sont organis√©s selon les conventions Expo pour permettre une g√©n√©ration automatique des ic√¥nes et √©crans de d√©marrage adapt√©s √† chaque plateforme. Cette approche me fait √©conomiser un temps pr√©cieux en automatisant les t√¢ches r√©p√©titives de cr√©ation d'assets sp√©cifiques √† chaque plateforme.

### Partage de la logique m√©tier

L'application mobile, d√©velopp√©e avec React Native et Expo, b√©n√©ficie pleinement de l'architecture monorepo en r√©utilisant l'ensemble des packages partag√©s : `@dropit/schemas` pour la validation, `@dropit/contract` pour les appels API typ√©s, `@dropit/permissions` pour les autorisations, et `@dropit/i18n` pour les traductions.

Cette r√©utilisation garantit une coh√©rence parfaite des r√®gles m√©tier entre les plateformes web et mobile, √©liminant les risques de divergence fonctionnelle.

### Async storage 

Le stockage mobile utilise AsyncStorage pour conserver le token d'authentification localement, contrairement au web qui utilise des cookies httpOnly. Cette approche permet une authentification persistante et pourrait √™tre √©tendue pour une utilisation hors-ligne partielle, particuli√®rement utile en salle de sport o√π la connectivit√© peut √™tre limit√©e.

> **Impl√©mentation React Native compl√®te** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/)

## Consid√©rations de performance

J'ai appliqu√© plusieurs optimisations classiques du d√©veloppement React moderne, en √©vitant l'optimisation pr√©matur√©e qui nuit √† la lisibilit√© :

- **Lazy loading** des composants volumineux pour r√©duire le bundle initial
- **Memoization** des calculs co√ªteux pour √©viter les recalculs inutiles  
- **Debouncing** des recherches pour limiter les appels r√©seau excessifs

Ces optimisations ciblent les probl√©matiques courantes : chargement diff√©r√© des composants lourds, √©vitement des calculs redondants, et limitation des appels r√©seau excessifs. Dans le contexte d'usage de DropIt (quelques dizaines d'utilisateurs par club), ces optimisations suffisent largement.

> **Exemples d'optimisations React** : Voir l'[Annexe - Impl√©mentation des pr√©sentations](/annexes/implementation-presentations/)


## Bilan des choix architecturaux frontend

L'architecture des couches de pr√©sentation que j'ai mise en place illustre concr√®tement l'application des patterns architecturaux : organisation par features, validation Zod partag√©e, gestion d'√©tat avec Tanstack Query, et composants Shadcn/ui avec TailwindCSS.

Ces choix techniques - React/TypeScript pour le web, React Native pour le mobile, packages partag√©s du monorepo - cr√©ent un √©cosyst√®me coh√©rent o√π la logique m√©tier reste centralis√©e tout en permettant des adaptations sp√©cifiques √† chaque plateforme.

Maintenant que cette fondation architecturale est √©tablie, la section suivante d√©taille la conception des interfaces utilisateur et les wireframes qui mat√©rialisent ces choix techniques en exp√©rience utilisateur concr√®te.  